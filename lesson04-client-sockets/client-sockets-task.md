
# Базовая задача

Разработать клиентское приложение для получения и передачи строковых значений
на сервер с помощью учебного протокола. В зависимости от аргументов командной
строки приложение передает на сервер строку для хранения или запрашивает ранее
сохраненное значение. Обмен данными с сервером производится через пакетные
UNIX-сокеты.

## Описание базовой задачи

Для взаимодействия клиентского и серверного приложений необходим протокол.
В качестве данного протокола используется следующий набор правил
взаимодействия между клиентом и сервером:

Запрос к серверу и ответ от него состоят из заголовка и тела.

| TYPE (1 байт) | SID (1 байт) | PS (1 байт) | PAYLOAD (0-255 байт) |
|---------------|--------------|-------------|----------------------|

Заголовок: **TYPE** + **SID** + **PS** = 3 байта.
Тело: **PAYLOAD** от 0 до 255 байт.

- **TYPE** - тип операции. Значение типа **unsigned char**.
  Допустимые значения:

  - **1** - запрос клиента на сохранение значения на сервере;
  - **2** - запрос клиента на получение значения с сервера;
  - **3** - ответ от сервера.

- **SID** (Slot ID) - идентификатор слота. Значение типа **unsigned char**.
  Допустимые значения: **0 - 255**.

- **PS** (Payload Size) - размер полезной нагрузки (количество байтов).
  Значение типа **unsigned char**. Допустимые значения: **0 - 255**.
  Если для поля **TYPE** заголовка задано значение **2**, то значение поля
  **PS** должно быть равно **0**.

- **PAYLOAD** - Полезная нагрузка. Произвольный набор байтов.
  Допустимый размер набора: **0 - 255** байтов. Если для поля **TYPE**
  заголовка задано значение **2**, то размер поля **PAYLOAD** должен быть
  равен **0**.

По умолчанию ответы от сервера для потокового UNIX-сокета намеренно не
фрагментируются. Данное поведение можно изменить воспользовавшись опциями
**-f** или **--fragment-messages** сервера. После указания одной из данных
опций сообщения начнут фрагментироваться. Пример:

```console
$ ./lab_04_server -f
```

## Алгоритм решения базовой задачи

1. Осуществить анализ аргументов командной строки с помощью **argv**
   и **argc**. В качестве аргументов командной строки использовать следующие:

   - **TYPE** для аргумента, соответствующего типу операции;
   - **SID** для аргумента, соответствующего идентификатору слота;
   - **PAYLOAD** для аргумента, соответствующего полезной нагрузке.

   Все аргументы являются позиционными. Аргументы **TYPE** и
   **SID** обязательные. Аргумент **PAYLOAD** необязательный. Аргумент
   **PAYLOAD** является строкой с завершающим нулевым байтом. В случае
   отсутствия аргумента **PAYLOAD**, тело запроса считать пустой строкой с
   завершающим нулевым байтом. В случае несоответствия количества обязательных
   позиционных аргументов указанному выше, необходимо записать соответствующее
   сообщение об ошибке в стандартный поток ошибки (stderr) и завершить
   программу с кодом возврата **EXIT_FAILURE**.

2. Принять следующие макроопределения:

    ```c
    #define SOCK_DGRAM_SERVER_PATH "/tmp/sock_dgram_server"
    #define HEADER_SIZE 3
    #define PAYLOAD_SIZE 255
    #define SET 1
    #define GET 2
    ```

    В данном случае:

    - **SOCK_DGRAM_SERVER_PATH** - публичный адрес сервера;
    - **HEADER_SIZE** - общий размер заголовка;
    - **PAYLOAD_SIZE** - максимальный размер полезной нагрузки;
    - **SET** - запрос клиента на сохранение значения на сервере;
    - **GET** - запрос клиента на получение значения с сервера;

3. Создать клиентский пакетный UNIX-сокет с помощью функции [socket(2)][1].

4. Назначить клиентскому пакетному UNIX-сокету динамический адрес.
   Для этого необходимо воспользоваться функцией [bind(2)][2], указав в
   качестве аргумента `addrlen` значение `sizeof(sa_family_t)`.

5. Сгенерировать запрос для отправки серверу. Для генерации использовать
   предлагаемые в макроопределениях смещения. Отправить запрос. Для отправки
   запроса использовать функцию [sendto(2)][3]. Запрос отправлять на публичный
   адрес сервера **SOCK_DGRAM_SERVER_PATH**.

6. Если в предыдущем пункте запрос подразумевал наличие ответа, то необходимо
   получить ответ от сервера и отобразить его в эмуляторе терминала.
   Для получения ответа использовать функцию [recv(2)][4].

7. Закрыть клиентский пакетный UNIX-сокет с помощью функции [close(2)][5].

8. Завершить программу.

[1]: https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=socket&category=2
[2]: https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=bind&category=2
[3]: https://www.opennet.ru/man.shtml?topic=sendto&category=2&russian=0
[4]: https://www.opennet.ru/man.shtml?topic=recv&category=2&russian=0
[5]: https://www.opennet.ru/man.shtml?topic=close&category=2&russian=0
[6]: https://www.opennet.ru/man.shtml?topic=strlen&category=3&russian=0
[7]: https://www.opennet.ru/man.shtml?topic=snprintf&category=3&russian=0

## Примеры для базовой задачи

1. Анализ аргументов командной строки.  
   См. Лабораторная работа №2, пример №1.

2. Создание пакетного UNIX-сокета с динамическим адресом.

    ```c
    #include <sys/socket.h>
    #include <sys/un.h>

    struct sockaddr_un addr;
    int sfd;
    int ret;

    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
    if (sfd == -1) {
            /* Handle error here. */
    }

    addr.sun_family = AF_UNIX;

    ret = bind(sfd, (const struct sockaddr *) &addr, sizeof(sa_family_t));
    if (ret == -1) {
            /* Handle error here. */
    }
    ```

3. Заполнение структуры, описывающей адрес сервера.

    ```c
    #include <string.h>
    #include <stdio.h>
    #include <sys/socket.h>
    #include <sys/un.h>

    struct sockaddr_un addr;
    char *socket_path;

    if (strlen(socket_path) > sizeof(addr.sun_path) - 1) {
            /* Handle error here. */
    }

    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    snprintf(addr.sun_path, sizeof(addr.sun_path), "%s", socket_path);
    ```

    Функция [strlen(3)][6] служит для определения длины строки.  
    Функция [snprintf(3)][7] служит для создания форматированной строки.

4. Генерация запроса для сервера. **SID** = 100, **PAYLOAD** = "Test!".

    ```c
    #include <string.h>
    #include <stdio.h>

    char buffer_tx[HEADER_SIZE + PAYLOAD_SIZE];
    char *payload = "Test!";

    buffer_tx[0] = SET;
    buffer_tx[1] = 100;
    buffer_tx[2] = strlen(payload) + 1;
    snprintf(buffer_tx + HEADER_SIZE, buffer_tx[2], "%s", payload);
    ```

5. Отправка запроса серверу.

    ```c
    #include <sys/socket.h>
    #include <sys/un.h>

    int sfd;
    char *buffer_tx;
    size_t tx_size;
    struct sockaddr_un server_address;
    ssize_t n_write;

    n_write = sendto(sfd,
                     buffer_tx,
                     tx_size,
                     0,
                     (const struct sockaddr *) &server_address,
                     sizeof(struct sockaddr_un);
    if (n_write != tx_size) {
            /* Handle error here. */
    }
    ```

6. Получение ответа от сервера.

    ```c
    #include <sys/socket.h>

    int sfd;
    char *buffer_rx;
    ssize_t n_read;

    n_read = recv(sfd, buffer_rx, HEADER_SIZE + PAYLOAD_SIZE, 0);
    if (n_read == -1) {
            /* Handle error here. */
    }
    ```

7. Отображение ответа от сервера.

    ```c
    #include <stdio.h>

    char *buffer_rx;

    fprintf(stdout,
            "Server response: <%d><%d><%d>:<%s>\n",
            buffer_rx[0],
            buffer_rx[1],
            buffer_rx[2],
            buffer_rx + HEADER_SIZE);
    ```

# Усложненная задача

Решить базовую задачу с использованием потоковых UNIX-сокетов. Приложение
должно восстанавливать целый ответ от сервера из отдельных фрагментов, а также
детектировать разрыв соединения с сервером.

## Рекомендации по выполнению усложненной задачи

При отправке и получении данных необходимо учесть, что границы запросов/ответов
не соблюдаются, т.е. возможна частичная отправка сообщения серверу и/или
частичный прием ответа от сервера. Стоит отметить, что фрагментация запроса/ответа
может произойти в любом месте, даже в заголовке. Таким образом для корректного
приема ответа от сервера требуется сначала полностью принять заголовок,
а затем, на основании длины сообщения, указанного в заголовке, принять само
сообщение.

# Наблюдение результатов

Для наблюдения работы клиентского приложения необходимо запустить два эмулятора
терминала. В первом эмуляторе терминала запустить серверное приложение.
Сообщения об ошибках серверное приложение будет помещать в стандартных поток
ошибок (stderr).

```console
$ ./lab_04_server -f -t
```

Во втором эмуляторе терминала запустить клиентское приложение. Далее,
необходимо сначала сохранить сообщение на сервере, а затем получить его.
Например:

```console
$ ./lab_04_bt 1 100 test_message
$ ./lab_04_bt 2 100
Server response: <3><100><13>:<test_message>
```
